<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>AJAX与Fetch</title>
      <link href="/2018/11/22/AJAX%E4%B8%8EFetch/"/>
      <url>/2018/11/22/AJAX%E4%B8%8EFetch/</url>
      
        <content type="html"><![CDATA[<p>之前总是用封装好的异步请求方法，对最原始的AJAX和Fetch并不是很熟知，现在整理一波</p><a id="more"></a><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX 是异步的JavaScript和XML(Asynchronous JavaScript And XML)，简单来说，就是使用XMLHttpRequest对象与服务器通信。</p><ul><li>AJAX可以使用JSON、XML、HTML、text等格式发送和接受数据</li><li>因为它的“异步”特性，可以在不刷新页面情况下与服务器通信</li></ul><h3 id="XMLHTTPRequest-readyState-的几种状态"><a href="#XMLHTTPRequest-readyState-的几种状态" class="headerlink" title="XMLHTTPRequest.readyState 的几种状态"></a>XMLHTTPRequest.readyState 的几种状态</h3><ul><li>0 (未初始化) or (请求还未初始化)</li><li>1 (正在加载) or (已建立服务器链接)</li><li>2 (加载成功) or (请求已接受)</li><li>3 (交互) or (正在处理请求)</li><li>4 (完成) or (请求已完成并且响应已准备好)</li></ul><h3 id="POST-请求几种编码方式（Content-type）"><a href="#POST-请求几种编码方式（Content-type）" class="headerlink" title="POST 请求几种编码方式（Content-type）"></a>POST 请求几种编码方式（Content-type）</h3><ul><li><p>Content-Type: application/x-www-form-urlencoded (default):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=bar&amp;baz=The+first+line.&amp;#37;0D%0AThe+second+line.%0D%0A</span><br></pre></td></tr></table></figure></li><li><p>Content-Type: text/plain</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line">baz=The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure></li><li><p>Content-Type: multipart/form-data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;foo&quot;</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">-----------------------------314911788813839</span><br><span class="line">Content-Disposition: form-data; name=&quot;baz&quot;</span><br><span class="line"></span><br><span class="line">The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure></li></ul><h3 id="一个简单的Ajax请求例子"><a href="#一个简单的Ajax请求例子" class="headerlink" title="一个简单的Ajax请求例子"></a>一个简单的Ajax请求例子</h3><ul><li><p>Ajax方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option 为对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr;</span><br><span class="line">  <span class="comment">// 兼容各个浏览器</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;   <span class="comment">// 主流浏览器 IE7+</span></span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;  <span class="comment">// IE6-</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> method = option.method.toUpperCase();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">async</span> = option.async | <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> url = option.url;</span><br><span class="line">  xhr.timeout = option.timeout | <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> paramArr = [];</span><br><span class="line">  <span class="keyword">if</span> (option.params <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> param <span class="keyword">of</span> <span class="built_in">Object</span>.keys(option.params)) &#123;</span><br><span class="line">      paramArr.push(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(param)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(option.params[param])&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">      url = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramArr.join(<span class="string">'&amp;'</span>)&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    xhr.ontimeout = <span class="function"><span class="params">()</span> =&gt;</span> reject &amp;&amp; reject(<span class="string">'请求超时！'</span>);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断XMLHttpRequest状态</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回数据状态</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> resolve &amp;&amp; resolve(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="string">'系统异常！'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.onerror = <span class="function"><span class="params">err</span> =&gt;</span> reject &amp;&amp; reject(err)</span><br><span class="line"></span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">      xhr.send(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>);</span><br><span class="line">      xhr.send(paramArr.join(<span class="string">'&amp;'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'/getSomething'</span>,</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    a: <span class="string">'11'</span>,</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res-get'</span>, <span class="built_in">JSON</span>.parse(res));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'/sendSomething'</span>,</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    a: <span class="string">'有吗'</span>,</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res-post'</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p><p>与XMLHttpRequest有两个不同点：</p><ul><li>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li><li>默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）</li></ul><p>credentials有三种值：</p><ul><li><code>credentials: &#39;include&#39;</code> : 浏览器发送包含凭据的请求（即使是跨域源）</li><li><code>credentials: &#39;same-origin&#39;</code> : 在请求URL与调用脚本位于同一起源处时发送凭据</li><li><code>credentials: &#39;omit&#39;</code> : 确保浏览器不在请求中包含凭据</li></ul><h3 id="简单的fetch请求"><a href="#简单的fetch请求" class="headerlink" title="简单的fetch请求"></a>简单的fetch请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'http://example.com/movies.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">myJson</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myJson);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AJAX </tag>
            
            <tag> Fetch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试常见算法</title>
      <link href="/2018/11/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>现在整理一波面试中常遇到的算法</p><a id="more"></a><ol><li>排序算法   三种n&amp;2，快排，归并，堆排</li><li>二叉树三序遍历算法</li><li>全排列、全组合</li><li>简单DP</li><li>链表遍历，插入，删除</li><li>二分搜索</li></ol><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((low + high) / <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> midNum = nums[mid];</span><br><span class="line">    <span class="keyword">if</span> (midNum === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midNum &lt; target) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见跨域总结</title>
      <link href="/2018/11/20/%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/20/%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>面试时经常会被问到跨域问题，因此，在此做个详细的总结<br><a id="more"></a></p><h1 id="跨域总结"><a href="#跨域总结" class="headerlink" title="跨域总结"></a>跨域总结</h1><h2 id="为什么会出现跨域问题"><a href="#为什么会出现跨域问题" class="headerlink" title="为什么会出现跨域问题"></a>为什么会出现跨域问题</h2><ul><li>出于浏览器同源策略限制，浏览器会拒绝跨域的读操作请求。</li><li>同源策略是一个用于隔离潜在恶意文件的重要安全机制。</li><li>同源的定义： 如果两个页面的协议、端口、域名都相同，则同源。非同源请求，均为跨域</li></ul><h2 id="如何实现跨域"><a href="#如何实现跨域" class="headerlink" title="如何实现跨域"></a>如何实现跨域</h2><p>  最常用的跨域方式有以下四种：<strong>JSONP、 CORS、 postMessage、 WebSocket</strong></p><h3 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h3><p><strong>JSONP是一种比较hack的方式，单纯的为了实现跨域请求而创造的一个trick.</strong></p><p>JSONP的核心是动态添加&lt; script &gt;标签来调用服务器提供的js脚本。ajax的核心是通过XMLHttpRequest获取非本页内容。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点： 兼容性好，能兼容到低版本IE</li><li>缺点： 1.JSONP只支持GET请求；2.XMLHttpRequest相对于JSONP有着更好的错误处理机制 </li></ul><h4 id="实现方式（需前后端配合）"><a href="#实现方式（需前后端配合）" class="headerlink" title="实现方式（需前后端配合）"></a>实现方式（需前后端配合）</h4><p>原理： &lt; script &gt;标签的src属性是可以跨域的。传递一个<code>callback</code>参数给跨域服务端，返回数据时将这个<code>callback</code>参数作为函数名包裹要返回的json数据。</p><ul><li><p>webA的前端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>JSONP Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一种方式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script&gt;</span></span><br><span class="line"><span class="comment">  function getData(data) &#123;</span></span><br><span class="line"><span class="comment">    var text = document.createElement('p');</span></span><br><span class="line"><span class="comment">    text.innerHTML = data;</span></span><br><span class="line"><span class="comment">    document.getElementsByTagName('body')[0].appendChild(text);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src="http://localhost:3003/jsonp?callback=getData"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  function getData(data) &#123;</span></span><br><span class="line"><span class="undefined">    var text = document.createElement('p');</span></span><br><span class="line"><span class="undefined">    text.innerHTML = data;</span></span><br><span class="line"><span class="undefined">    document.getElementsByTagName('body')[0].appendChild(text);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  var url = 'http://localhost:3003/jsonp?callback=getData';</span></span><br><span class="line"><span class="undefined">  var script = document.createElement('script');</span></span><br><span class="line"><span class="undefined">  script.setAttribute('src', url);</span></span><br><span class="line"><span class="undefined">  document.getElementsByTagName('head')[0].appendChild(script);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>webA的后端</p><ul><li>node.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    ctx.body = fs.readFileSync(<span class="string">'./jsonp.html'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure></li><li><p>webB的后端</p><ul><li>php</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $callback = $_GET[<span class="string">'callback'</span>]; <span class="comment">// 得到回调函数名</span></span><br><span class="line">  $data = <span class="string">'demo'</span>;  <span class="comment">// 要返回的数据</span></span><br><span class="line">  <span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>; <span class="comment">// 输出回前端</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ul><li>node.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.originalUrl.split(<span class="string">'?'</span>)[<span class="number">0</span>] === <span class="string">'/jsonp'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callback = ctx.originalUrl.split(<span class="string">'?'</span>)[<span class="number">1</span>].split(<span class="string">'='</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">'连接成功！'</span>;</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;callback&#125;</span>('<span class="subst">$&#123;data&#125;</span>')`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3003</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、CORS（跨域资源共享-cross-origin-sharing-standard）"><a href="#二、CORS（跨域资源共享-cross-origin-sharing-standard）" class="headerlink" title="二、CORS（跨域资源共享 cross-origin sharing standard）"></a>二、CORS（跨域资源共享 cross-origin sharing standard）</h3><ul><li>CORS 是W3C推荐的一种新的官方方案，能使服务器支XMLHttpRequest的跨域请求。</li><li>CORS实现起来非常方便，只需增加一些HTTP头，让服务器能声明允许的访问来源。</li><li>通常使用CORS时，异步请求会被分为简单请求和非简单请求，区别是，非简单请求会先使用<code>OPTIONS</code>方法发起一个预检请求(<code>prefight request</code>)，获知服务端是否允许跨域请求</li><li>需要后端接口配合，加上一些响应头字段</li></ul><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>满足以下条件的可视为简单请求：</p><ul><li>Method 为 <code>GET</code> 、<code>HEAD</code> 、<code>POST</code>之一</li><li>Fetch 规定了对CORS安全的首部字段集合，如人为设定了集合之外的其他首部字段，则就不是简单请求了。集合如下<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type 的值仅限于 <code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>请求中的任意<code>XMLHttpRequestUpload</code>对象均没有注册任何时间监听器</li><li>请求中没有使用<code>ReadableStream</code>对象</li></ul><h5 id="请求、响应头部的特点"><a href="#请求、响应头部的特点" class="headerlink" title="请求、响应头部的特点"></a>请求、响应头部的特点</h5><ul><li>请求头部需带上<code>Origin：[originURL]</code></li></ul><p><em> 服务端响应会携带首部字段`Access-Control-Allow-Origin: [originURL] | </em>`</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>不满足简单请求条件的跨域请求都是非简单请求。非简单请求需要先发预检请求，得到允许后，再发送正常请求去请求数据。</p><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>非简单请求必须首先使用<code>OPTIONS</code>方法发起一个预检请求到服务器，以获取服务器是否允许该实际请求</p><ul><li><p>预检请求头部字段</p><ul><li><code>Origin: &lt;origin&gt;</code> 表明预检请求或实际请求的源站</li><li><code>Access-Control-Request-Method: &lt;method&gt;</code> 将实际请求所使用的 HTTP 方法告诉服务器</li><li><code>Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code> 将实际请求所携带的首部字段告诉服务器</li></ul></li><li><p>预检响应首部字段</p><ul><li><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code> 指定了允许访问资源的外域URI</li><li><code>Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code> 指明了实际请求所允许使用的 HTTP 方法</li><li><code>Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code> 指明了实际请求中允许携带的首部字段。</li><li><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code> 指定了预检请求结果能被缓存多久，也就是关于实际请求多久不需要再次发送预检请求</li></ul></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>如果用的koa框架搭建的后台，可以用<code>koa-cors</code>中间件来配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">'koa-cors'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cors跨域配置</span></span><br><span class="line">app.use(cors(&#123;</span><br><span class="line">  origin: <span class="string">'*'</span>,</span><br><span class="line">  headers: [<span class="string">'Cache-Control'</span>, <span class="string">'Content-Type'</span>],</span><br><span class="line">  methods: [<span class="string">'GET'</span>, <span class="string">'PUT'</span>, <span class="string">'POST'</span>]</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.originalUrl.split(<span class="string">'?'</span>)[<span class="number">0</span>] === <span class="string">'/jsonp'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callback = ctx.originalUrl.split(<span class="string">'?'</span>)[<span class="number">1</span>].split(<span class="string">'='</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">'连接成功！'</span>;</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;callback&#125;</span>('<span class="subst">$&#123;data&#125;</span>')`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.url === <span class="string">'/corsPostSomething'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ctx11'</span>, ctx);</span><br><span class="line">    ctx.body = <span class="string">'跨域过来的东西收到了'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3003</span>);</span><br></pre></td></tr></table></figure><h3 id="三、window-postMessage"><a href="#三、window-postMessage" class="headerlink" title="三、window.postMessage"></a>三、window.postMessage</h3><p>主要是为了 <code>&lt;iframe&gt;</code> 标签镶嵌的两个页面进行数据通信用的，需要两个页面的前端配合。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>发送 <code>otherWindow.postMessage(msg, targetOrigin [, transfer])</code></li><li>监听  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, func, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin;</span><br><span class="line">  <span class="keyword">if</span> (origin != <span class="string">'http://xxx:8080'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>两个窗口都需要绑定上述方法，才能互相通信。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>webA的代码(主页面，用<code>iframe</code>嵌入webB):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>下面是内嵌页面<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">contentWindow</span>=<span class="string">"webBPage"</span> <span class="attr">src</span>=<span class="string">"http://localhost:3003"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser does not support iframes.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 一定是页面加载完成后在发送消息，否则会因为 iframe 未加载完成报错</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'child'</span>).contentWindow.postMessage(<span class="string">"主页面消息"</span>, <span class="string">"http://localhost:3003"</span>)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 我们能相信信息的发送者吗?  (也许这个发送者和我们最初打开的不是同一个页面).</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.origin !== <span class="string">"http://localhost:3003"</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> text = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span></span><br><span class="line"><span class="undefined">    text.innerHTML = event.data;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(text);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>webB的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>webB页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.origin !== <span class="string">"http://localhost:3001"</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> text = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span></span><br><span class="line"><span class="undefined">    text.innerHTML = event.data;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(text);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 作为回信的对象，并且把event.origin作为targetOrigin</span></span></span><br><span class="line"><span class="javascript">    event.source.postMessage(<span class="string">"这是B呀"</span>, event.origin);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、WebSocket"><a href="#四、WebSocket" class="headerlink" title="四、WebSocket"></a>四、WebSocket</h3><p>WebSocket 是独立的、建立在TCP上的协议，是一种在浏览器与服务器之间保持TCP长连接的网络协议，能让浏览器、服务器可以随时进行信息交换，通过HTTP/1.1协议的<strong>101状态码</strong>进行<strong>握手</strong>(浏览器发出请求，之后服务器进行回应)</p><p>在还未有该协议时，使用的是<strong>轮询</strong>的方法，让客户端每隔一段时间都发送请求去询问服务器是否准备好数据了。也就是解决了“客户端无法获知请求的动态资源何时到位“这个问题。</p><p>之所以跟跨域有关系，是因为<strong>当客户端与服务器端创建WebScoket连接后，本身就可以天然的实现跨域资源共享，因为WebSocket协议本身就不受浏览器“同源策略”的限制，同源策略只是限制了跨域的AJAX请求。</strong></p><h4 id="构造函数与属性方法"><a href="#构造函数与属性方法" class="headerlink" title="构造函数与属性方法"></a>构造函数与属性方法</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul><li><code>WebSocket(url[, protocols])</code> 如：let socket = new WebSocket(‘http//baidu.com:8080’)</li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><code>WebSocket.binaryType</code> 使用二进制数据类型进行连接</li><li><code>WebSocket.onclose</code> 指定连接关闭后的回调函数</li><li><code>WebSocket.onerror</code> 指定连接失败后的回调函数</li><li><code>WebSocket.onmessge</code> 指定从服务器接收到信息时的回调函数</li><li><code>WebSocket.onopen</code> 指定连接成功后的回调函数</li><li><code>WebSocket.protocol</code> <strong>只读</strong> 服务器选择的下属协议</li><li><code>WebSocket.readyState</code> <strong>只读</strong> 当前连接状态，0：正在连接中；1：连接成功；2：连接正在关闭；3：连接已经关闭或打开连接失败</li><li><code>WebSocket.url</code> <strong>只读</strong> WebSocket 的绝对路径</li><li><code>WebSocket.bufferedAmount</code> <strong>只读</strong> 未发送至服务器的字节数</li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li><code>WebSocket.close([code, reason])</code> 关闭当前连接</li><li><code>WebSocket.send(data)</code> 向服务器发送数据</li></ul><h4 id="典型的Websocket握手请求"><a href="#典型的Websocket握手请求" class="headerlink" title="典型的Websocket握手请求"></a>典型的Websocket握手请求</h4><h5 id="浏览器请求头"><a href="#浏览器请求头" class="headerlink" title="浏览器请求头"></a>浏览器请求头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: websocket      // 必须，表示希望升级到Websocket协议</span><br><span class="line">Connection: Upgrade     // 必须，表示客户端希望连接升级</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http://example.com   // 客户端的origin，协议和主机名称</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==   // 随机字符串，用来SHA-1、BASE-64编码后，作为`Sec-WebSocket-Accept`头的值返回给客户端</span><br><span class="line">Sec-WebSocket-Version: 13 // RFC6455要求使用的版本是13，之前草案的版本均应当弃用</span><br></pre></td></tr></table></figure><h5 id="服务器响应头"><a href="#服务器响应头" class="headerlink" title="服务器响应头"></a>服务器响应头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>http 为 ws, https 为 wss</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws//baidu.com:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection opened</span></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发送完毕</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 还在发送</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for messages</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Message from server '</span>, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>]]></content>
      
      
      
        <tags>
            
            <tag> AJAX </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flex布局学习</title>
      <link href="/2018/11/01/Flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/11/01/Flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Flex布局相关CSS的简单说明<br><a id="more"></a></p><h3 id="两根轴线"><a href="#两根轴线" class="headerlink" title="两根轴线"></a>两根轴线</h3><ul><li><p>主轴 由 flex-direction 的值确定，值如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: &#123;</span><br><span class="line">  row             <span class="comment">// 横 左到右 初始值</span></span><br><span class="line">  row-reverse     <span class="comment">// 横 右到左</span></span><br><span class="line">  column          <span class="comment">// 竖 上到下</span></span><br><span class="line">  column-reverse  <span class="comment">// 竖 下到上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交叉轴 与主轴垂直</p></li></ul><h3 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h3><p>采用了flexbox的区域就是flex容器。把一个容器的<code>display</code>属性值改为<code>flex</code>或<code>inline-flex</code>，容器中的直系子元素就会变成flex元素，所有flex元素都有以下一个初始值：</p><ul><li>元素排列为一行 (flex-direction 属性的初始值是 row)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li>flex-basis 属性为 auto。</li><li>flex-wrap 属性为 nowrap。</li></ul><p>这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。</p><p>所以应该把每一行看作一个新的flex容器，任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>可用flex-wrap实现多行Flex容器<br>cross-start 会根据 flex-direction 的值选择等于start 或before。cross-end 为确定的 cross-start 的另一端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: &#123;</span><br><span class="line">  nowrap          <span class="comment">// 初始值，挤在一行，可能导致溢出</span></span><br><span class="line">  wrap            <span class="comment">// lex 元素被打断到多个行中,</span></span><br><span class="line">  wrap-reverse    <span class="comment">// 与wrap的行为一样，cross-start和cross-end互换。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-direction-与-flex-wrap-简写成-flex-flow"><a href="#flex-direction-与-flex-wrap-简写成-flex-flow" class="headerlink" title="flex-direction 与 flex-wrap 简写成 flex-flow"></a>flex-direction 与 flex-wrap 简写成 flex-flow</h3><p><code>flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;</code></p><h3 id="flex-gt-flex-grow-flex-shrink-flex-basis"><a href="#flex-gt-flex-grow-flex-shrink-flex-basis" class="headerlink" title="flex -&gt; flex-grow flex-shrink flex-basis"></a>flex -&gt; flex-grow flex-shrink flex-basis</h3><p>flex规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间。这是一个简写属性，用来设置flex-grow, flex-shrink与flex-basis。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex: &#123;</span><br><span class="line">  auto      -&gt; flex: <span class="number">1</span> <span class="number">1</span> auto</span><br><span class="line">  initial   -&gt; flex: <span class="number">0</span> <span class="number">1</span> auto</span><br><span class="line">  none      -&gt; flex: <span class="number">0</span> <span class="number">0</span> auto</span><br><span class="line">  &lt;positive-number&gt;   -&gt; flex: &lt;positive-number&gt; 1 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-grow 属性定义弹性盒子项（flex item）的拉伸因子</li><li>flex-shrink 属性指定了 flex 元素的收缩规则.flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值</li><li>flex-basis 指定了 flex 元素在主轴方向上的初始大小</li></ul><h4 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h4><ul><li><p>align-items 属性可以使元素在交叉轴方向对齐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">align-items: &#123;</span><br><span class="line">  stretch   <span class="comment">// 默认值</span></span><br><span class="line">  flex-start</span><br><span class="line">  flex-end</span><br><span class="line">  center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>justify-content属性用来使元素在主轴方向上对齐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">justify-content: &#123;</span><br><span class="line">  stretch</span><br><span class="line">  flex-start</span><br><span class="line">  flex-end</span><br><span class="line">  center</span><br><span class="line">  space-around</span><br><span class="line">  space-between</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flex </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础页面开发步骤（H5/web）</title>
      <link href="/2018/10/28/%E5%9F%BA%E7%A1%80%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/"/>
      <url>/2018/10/28/%E5%9F%BA%E7%A1%80%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>对有设计稿的基础页面开发的一些简单步骤介绍<br><a id="more"></a></p><h2 id="基础页面开发"><a href="#基础页面开发" class="headerlink" title="基础页面开发"></a>基础页面开发</h2><p>  能根据设计稿(<code>PSD</code>/ <code>Sketch</code>)及交互要求，使用<code>Javascript</code>、<code>CSS</code>、<code>HTML</code>等技术将设计稿高保真转化为 网页的能力。</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ul><li>设计稿审查</li><li>确定设计稿的开发友好性（是否有还原成本高或无法还原的地方）</li><li>确定一些特殊的元素是否有合理的边界处理（如文案超出外层容器的边界怎么办）</li><li>确定页面的框架结构（Layout）</li><li>确定跨页面可复用的组件（Site Component）</li><li>确定当前页面可复用的组件（Page Component）</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ul><li><p>一般浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">盒子总宽度 = width + padding + border + margin</span><br></pre></td></tr></table></figure></li><li><p>IE浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">元素宽度 = width + padding + border</span><br><span class="line">盒子总宽度 = 元素宽度 + margin</span><br></pre></td></tr></table></figure><p>因此，<code>CSS3</code>新增了一个盒模型计算方式：<code>box-sizing</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box | padding-box | border-box;</span><br><span class="line">默认值：content-box</span><br></pre></td></tr></table></figure></li></ul><p>解决浏览器兼容方案如下，之后 <code>盒子总宽度 = width</code> ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五种布局"><a href="#五种布局" class="headerlink" title="五种布局"></a>五种布局</h3><ul><li><p>普通文档流布局</p><blockquote><p>默认的布局方式，由块级元素（display: block）和行内元素（display: inline）等组成，元素之间按照从左到右，从上到下的顺序排列。</p></blockquote></li><li><p>浮动布局(Float)</p><blockquote><p>相对于普通文档流布局，浮动布局会脱离普通文档流，分为左右浮动，一般会在普通文档流布局的上面进行界面的布局，如果想避免浮动布局遮盖普通布局的情况，可以考虑使用清除浮动。</p></blockquote></li><li><p>绝对布局(Absolute)</p><blockquote><p>元素使用 position: absolute 属性进行绝对布局，使用绝对布局的元素会脱离文档流，其定位是参考祖先元素中 position 为非 static 值的第一个元素。</p></blockquote></li><li>弹性布局(Flex)<blockquote><p>也称 Flex 布局，是一个完整的模块，而不是一个单一属性，其中有的属性是设置在父元素上，有些则是设置在子元素上。如果我们说传统的布局是建立在块级元素和行内元素的文本流上，那么 Flex 布局就是建立在 flex-flow 的轴方向上的。</p></blockquote></li><li>网格布局(Grid)<blockquote><p>是用于制定行与列的二维 CSS 布局方法，可以将页面分割成数个主要的区域，或者用来定义组件内部元素间的大小、位置和图层之间的关系</p></blockquote></li></ul><h3 id="CSS-命名规范"><a href="#CSS-命名规范" class="headerlink" title="CSS 命名规范"></a>CSS 命名规范</h3><ul><li><p>BEM</p><blockquote><p>BEM 的意思就模块（Block）、元素（Element）、修饰符（Modifier），使用这种命名方式可以让 CSS 的类名变得有实际意义且能自我解释，具有更高的开发友好性。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Block - 模块，名字的单词之间用 `-` 符号连接</span><br><span class="line">Element - 元素，模块中的子元素，用 `__` 符号连接</span><br><span class="line">Modifier - 修饰符，表示父元素或子元素的其他形态，用 `--` 符号连接</span><br></pre></td></tr></table></figure></li><li><p>ClassName 的命名应该尽量精短、明确，以英文单词命名，且全部<em> </em> 字母为小写，避免意义不明的缩写</p></li><li>单词之间统一使用下划线 _ 或 - 连接</li><li>学习 BEM 的思想，参考使用姓氏命名法规范</li><li>定义样式模块，提高代码的可复用性</li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>  关注下面两点：</p><ol><li>页面在各个浏览器中，以及不同分辨率下是否能正常显示（HTML / CSS 兼容性）</li><li><p>网页的功能是否能在各个浏览器中正常使用（JavaScript 兼容性）</p><p>兼容性的基本原则是<strong>渐进增强与平稳退化</strong>，在低端浏览器能够保持可用性和可访问性，然后再渐进增强，逐步增加功能及优化用户体验。</p><p>如果遇到兼容性问题，可以按如下步骤处理：</p></li><li>确认触发的场景：什么浏览器，什么版本，什么情况 下触发的问题，做到稳定复现。</li><li>找出问题原因：是什么问题导致的，具体表现如何？</li><li>确定解决办法：参考现成的解决方案，如哪些属性不能使用以及相应的 Hack 处理</li><li>收集兼容性处理方法，积累成文档</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 布局 </tag>
            
            <tag> 盒模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 文档不熟悉知识汇总</title>
      <link href="/2018/10/24/React-%E6%96%87%E6%A1%A3%E4%B8%8D%E7%86%9F%E6%82%89%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
      <url>/2018/10/24/React-%E6%96%87%E6%A1%A3%E4%B8%8D%E7%86%9F%E6%82%89%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>总结了对文档内出现不熟知的知识点，希望之后能一一深入学习理解<br><a id="more"></a></p><h2 id="React-官方文档"><a href="#React-官方文档" class="headerlink" title="React 官方文档"></a>React 官方文档</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ul><li><p>React 可以将多个setState() 调用合并成一个调用来提高性能，所以 this.props​ 与 this.state 是异步更新的，若想根据上个state来更新state，则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  count: prevState.count + props.num</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p>React 中，事件处理函数中阻止默认行为不能返回 false ，而是用  e.preventDefault(); 来解决 , e 是个合成事件，已解决了跨浏览器兼容问题；通过箭头函数，e 必须显示进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式进行传递。</p></li><li>数组元素必须为每个项配置一个key，并且在其兄弟中是独一无二的，并不需要在全局中唯一</li><li><strong>状态提升</strong>：任何可变的数据理应只有一个单一数据源，应在应用中保持自上而下的数据流，也就是把两个及以上组件共同使用的数据提升到其父组件上，而不是在不同组件中同步状态。</li><li>如果某些数据既可用 state 又可用 props 提供，那么它很有可能不应该在 state 中出现。</li><li>如果一个数据不是动态改变并且影响到渲染的，那么就不应该添加在 state 里。</li><li><strong>单一功能原则</strong>：尽量维持一个组件只做一件事情，如果这个组件的功能不断丰富，它应该被分成更小的组件</li><li>JSX 只是为了 <code>React.createElement(component, props, children)</code> 方法提供了语法糖。</li><li><p>Context 提供了一种在组件之间共享数据的方式，而不必通过组件树的每个层级显式地传递 props 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Provider, Consumer&#125; = React.createContext(defaultValue);</span><br><span class="line"></span><br><span class="line">&lt;Provider value=&#123;<span class="comment">/* some value */</span>&#125;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* render something based on the context value */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/Consumer&gt;</span></span><br></pre></td></tr></table></figure><p>每当Provider的值发送改变时, 作为Provider后代的所有Consumers都会重新渲染。 从Provider到其后代的Consumers传播不受shouldComponentUpdate方法的约束，因此即使祖先组件退出更新时，后代Consumer也会被更新。</p><p>高阶组件封装context</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数中引入组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 然后返回另一个组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最后使用context theme渲染这个被封装组件</span></span><br><span class="line">    <span class="comment">// 注意我们照常引用了被添加的属性</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        &#123;theme =&gt; &lt;Component &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="了解："><a href="#了解：" class="headerlink" title="了解："></a>了解：</h3><ul><li>使用propTypes进行props类型检查，如 <code>Demo.propTypes = {...};</code> ，出于性能原因， propTypes只在开发模式下进行检查</li><li><p><strong>Refs</strong>: 不能在函数式组件上使用 ref 属性，因为它们没有实例；当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref；当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。ref 的更新会发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 创建 ref 存储 textInput DOM 元素</span></span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">    <span class="comment">// 注意：通过 "current" 取得 DOM 节点</span></span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到构造器里创建的 `textInput` 上</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">      type=<span class="string">"text"</span></span><br><span class="line">      ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">      type=<span class="string">"button"</span></span><br><span class="line">      value=<span class="string">"Focus the text input"</span></span><br><span class="line">      onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>一个关于渲染属性API的问题是 refs 不会自动的传递给被封装的元素。为了解决这个问题，使用 React.forwardRef</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 context 传递当前的 "theme" 给 FancyButton.</span></span><br><span class="line"><span class="comment">// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;theme =&gt; (</span><br><span class="line">      &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure></li><li><p><strong>协同算法</strong>：</p><ol><li>两个不同类型的元素将产生不同的树。</li><li>通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。</li><li>当对比两棵树时，React首先比较两个根节点。每当根元素有不同类型，React将卸载旧树并重新构建新树。</li><li>当比较两个相同类型的React DOM元素时，React则会观察二者的属性，保持相同的底层DOM节点，并仅更新变化的属性。当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留</li><li>当递归DOM节点的子节点，React仅在同一时间点递归两个子节点列表，并在有不同时产生一个变更。为解决该问题，React支持了一个key属性。当子节点有key时，React使用key来匹配原本树的子节点和新树的子节点。</li><li>Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。</li></ol></li><li><p>Fragments: React 中一个常见模式是为一个组件返回多个元素。Fragments 可以让你聚合一个子元素列表，并且不在DOM中增加额外节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;   <span class="comment">// fragments</span></span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>###初次知道：</p><ul><li>静态类型检查：使用 Flow 和 TypeScript 静态类型检查器可以在运行代码之前识别某些类型问题</li><li>Create React App</li><li>uglify-js-brunch</li><li>Browserify</li><li>Rollup</li><li>使用 Chrome Performance 归档组件</li><li>Immutable.js是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：</li><li><p>Portals 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或碎片。第二个参数（container）则是一个 DOM 元素。对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上“跳出（break out）”其容器。例如，对话框、hovercards以及提示框：<br><code>ReactDOM.createPortal(child, container)</code></p></li><li><p><strong>错误边界:</strong> 如果一个类组件定义了一个名为 componentDidCatch(error, info): 的新方法，则其成为一个错误边界</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  <span class="comment">// Display fallback UI</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">  logErrorToMyService(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web组件</li><li>虚拟DOM（VDOM）是一种编程概念，是指虚拟的视图被保存在内存中，并通过诸如ReactDOM这样的库与“真实”的DOM保持同步。这个过程被称为和解。fiber是React 16中新的和解引擎。它的主要目的是使虚拟DOM能够进行增量渲染</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初步接触Vue.js</title>
      <link href="/2016/06/13/learnVueJS/"/>
      <url>/2016/06/13/learnVueJS/</url>
      
        <content type="html"><![CDATA[<p>Vue.js是一个数据驱动组件，由于工作需要，现开始学习，并做下学习笔记，以备今后查询解惑<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>vue.js是一个构建数据驱动的web界面的库，通过简单的api实现 <strong>响应的数据绑定</strong>  和  <strong>组合的视觉组件</strong>                </p></li><li><p>vue.js 的绑定视图DOM的方法与 angualar.js 很相似</p></li><li><p><strong>v-if</strong>  特性被称作指令。指令带有前缀 <strong>v-</strong> ，代表vue.js提供的特性，它们会给绑定的目标添加响应式的特殊行为。</p></li></ol><h2 id="组件的应用模板"><a href="#组件的应用模板" class="headerlink" title="组件的应用模板"></a>组件的应用模板</h2><pre><code>&lt;div id = &quot;app&quot;&gt;    &lt;app-nav&gt;&lt;/app-nav&gt;   &lt;app-view&gt;       &lt;app-sidebar&gt;&lt;/app-sidebar&gt;       &lt;app-content&gt;&lt;/app-content&gt;   &lt;/app-view&gt;&lt;/div&gt;</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h3 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a><strong>MVVM</strong> 模式</h3><pre><code>var vm = new Vue({     // MVVM模式中描述的ViewModel       //选项(数据、模板、挂载元素、方法、生命周期钩子)})</code></pre><h3 id="创建可复用的组件构造器"><a href="#创建可复用的组件构造器" class="headerlink" title="创建可复用的组件构造器"></a>创建可复用的组件构造器</h3><pre><code>所有的Vue.js组件其实都是被扩展的vue实例 var Mycomponent = Vue.extend({        // 扩展选项 })  // 所有的 ‘Mycomponent’ 实例都将以预定义的扩展选项被创建 var myComponentInstance = new Mycomponent()</code></pre><h2 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h2><h3 id="代理数据属性（响应）"><a href="#代理数据属性（响应）" class="headerlink" title="代理数据属性（响应）"></a>代理数据属性（响应）</h3><pre><code>每个vue实例都会代理其 **data** 对象里的所有属性   var data = { a : 1 }   var vm = new Vue ({       el: &apos;#example&apos;       data: data   })   vm.a === data.a   // true</code></pre><h3 id="实例属性与方法（带前缀-）"><a href="#实例属性与方法（带前缀-）" class="headerlink" title="实例属性与方法（带前缀 $）"></a>实例属性与方法（带前缀 <strong>$</strong>）</h3><pre><code>vm.$data === data  // truevm.$el === document.getElementById(&apos;example&apos;)   // true// $watch 是一个方法vm.$watch(&apos;a&apos;, function (newVal, oldVal) {    //这个回调将会在 &apos;vm.a&apos; 改变后调用})</code></pre><h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>   vue.js没有“控制器”的概念，组件的自定义逻辑都是分割在各种生命周期钩子上，<br>   包括 <strong>compiled</strong>、<strong>ready</strong>、<strong>destroyed</strong>、<strong>creaded</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/2145995-bc1002f101418414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/2145995-5dd367e30395c073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图示"></p>]]></content>
      
      
      <categories>
          
          <category> 阿里web前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> Angular.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 Yelee 主题背景图的压缩与优化</title>
      <link href="/2016/05/24/try-markdown/"/>
      <url>/2016/05/24/try-markdown/</url>
      
        <content type="html"><![CDATA[<p>目前主题里可以使用多张随机大图作背景，如果不做好图片压缩和优化，可能会严重影响网站的流畅性。下面简单介绍两种比较简单便捷的优化方案。<br><a id="more"></a></p><h2 id="优化说明"><a href="#优化说明" class="headerlink" title="优化说明"></a>优化说明</h2><ul><li>请使用<code>jpg</code>后缀名的背景图片；</li><li>如果可以，使用<code>渐进式JPEG</code>，让图片加载时逐渐清晰；</li><li>将图片品质尽量调低，一般可以压缩到几十kb（背景图半透明显示，因此细节并不重要）；<blockquote><p>图1 为目前主题自带背景图的分辨率和文件大小展示<br>图2 为渐进式图片加载示例</p></blockquote></li></ul><p><img src="/resources/image-compression-1.png" alt="Yelee Background info.">  <img src="/resources/image-compression-2.gif" alt="Progressive JPEGs"></p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="PhotoShop"><a href="#PhotoShop" class="headerlink" title="PhotoShop"></a>PhotoShop</h3><ul><li>电脑上如果安装了PhotoShop，那用其来优化图片那是再好不过了</li><li>PS 打开图片 -&gt; 文件 -&gt; 存储为 Web 所用格式 -&gt; JPEG 格式，品质 0，勾选 <code>连续</code>（渐进式），最后存储，这样一张高压缩渐进式的 JPG 背景图就做好了</li></ul><p><img src="/resources/image-compression-ps.png" alt="image Compression by PhotoShop"></p><h3 id="智图"><a href="#智图" class="headerlink" title="智图"></a>智图</h3><ul><li><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">智图</a> 是腾讯 ISUX 出品的在线图片优化工具，可以方便的对比优化前后的图片，同时可以自行调节图片品质，除了不能设置 <code>渐进式JPEG</code>，其他基本满足背景图片优化需求</li><li>进入网站后按提示上传图片，在调低图片品质，之后下载图片即可<blockquote><p>因为主题背景图为 <code>jpg</code>格式，其他格式请转为 <code>jpg</code> 格式后再上传到网上优化。转换的方式有很多，比如，打开图片预览后另存为jpg</p></blockquote></li></ul><p><img src="/resources/zhitu.png" alt="智图"></p><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>原图为 420kb，智图选择最低品质(10)后约为 129kb；</li><li>PhotoShop 选择最低品质 0，可以压缩到 62k，同时可以选择为 <code>渐进式JPEG</code>；</li><li>因此，有条件的话，更推荐使用 PS 压缩图片。</li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><strong>智图</strong>： <a href="http://zhitu.isux.us/" target="_blank" rel="noopener">http://zhitu.isux.us/</a></li><li><strong>TinyPNG</strong>： <a href="http://tinypng.com/" target="_blank" rel="noopener">http://tinypng.com/</a></li><li><strong><em>渐进式</em></strong>： by <strong>张鑫旭</strong> on <code>2013/01/07</code>: <a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/</a></li><li><strong>呆毛王示例壁纸下载</strong> <a href="http://moxfive.xyz/resources/saber.jpg" target="_blank" rel="noopener">http://moxfive.xyz/resources/saber.jpg</a></li><li><strong>最人性化的壁纸网站</strong> <a href="http://www.wallpaperpcmobile.com/" target="_blank" rel="noopener">http://www.wallpaperpcmobile.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 术业有专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yelee </tag>
            
            <tag> PhotoShop </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
