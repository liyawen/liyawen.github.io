<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>跨域总结</title>
      <link href="/2018/11/20/%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/20/%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>  面试时经常会被问到跨域问题，因此，在此做个详细的总结</p><a id="more"></a><h1 id="跨域总结"><a href="#跨域总结" class="headerlink" title="跨域总结"></a>跨域总结</h1><h2 id="为什么会出现跨域问题"><a href="#为什么会出现跨域问题" class="headerlink" title="为什么会出现跨域问题"></a>为什么会出现跨域问题</h2><ul><li>出于浏览器同源策略限制，浏览器会拒绝跨域的读操作请求。</li><li>同源策略是一个用于隔离潜在恶意文件的重要安全机制。</li><li>同源的定义： 如果两个页面的协议、端口、域名都相同，则同源。非同源请求，均为跨域</li></ul><h2 id="如何实现跨域"><a href="#如何实现跨域" class="headerlink" title="如何实现跨域"></a>如何实现跨域</h2><p>  最常用的跨域方式有以下四种：<strong>JSONP、 CORS、 postMessage、 WebSocket</strong></p><h3 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h3><p><strong>JSONP是一种比较hack的方式，单纯的为了实现跨域请求而创造的一个trick.</strong></p><p>JSONP的核心是动态添加&lt; script &gt;标签来调用服务器提供的js脚本。ajax的核心是通过XMLHttpRequest获取非本页内容。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点： 兼容性好，能兼容到低版本IE</li><li>缺点： 1.JSONP只支持GET请求；2.XMLHttpRequest相对于JSONP有着更好的错误处理机制 </li></ul><h4 id="实现方式（需前后端配合）"><a href="#实现方式（需前后端配合）" class="headerlink" title="实现方式（需前后端配合）"></a>实现方式（需前后端配合）</h4><p>原理： &lt; script &gt;标签的src属性是可以跨域的。传递一个<code>callback</code>参数给跨域服务端，返回数据时将这个<code>callback</code>参数作为函数名包裹要返回的json数据。</p><ul><li>前端</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"type/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理获得的数据</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求</span></span><br><span class="line">  <span class="comment">// 第一种做法：&lt;script src="http://example.com/data.php?callback=doSomething"&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="comment">// 第二种做法</span></span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">"http://example.com/data.php?callback=doSomething"</span>;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>后端</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $callback = $_GET[<span class="string">'callback'</span>]; <span class="comment">// 得到回调函数名</span></span><br><span class="line">  $data = <span class="keyword">array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);  <span class="comment">// 要返回的数据</span></span><br><span class="line">  <span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>; <span class="comment">// 输出回前端</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="二、CORS（跨域资源共享-cross-origin-sharing-standard）"><a href="#二、CORS（跨域资源共享-cross-origin-sharing-standard）" class="headerlink" title="二、CORS（跨域资源共享 cross-origin sharing standard）"></a>二、CORS（跨域资源共享 cross-origin sharing standard）</h3><ul><li>CORS 是W3C推荐的一种新的官方方案，能使服务器支XMLHttpRequest的跨域请求。</li><li>CORS实现起来非常方便，只需增加一些HTTP头，让服务器能声明允许的访问来源。</li><li>通常使用CORS时，异步请求会被分为简单请求和非简单请求，区别是，非简单请求会先使用<code>OPTIONS</code>方法发起一个预检请求(<code>prefight request</code>)，获知服务端是否允许跨域请求</li><li>需要前后端接口配合</li></ul><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>满足以下条件的可视为简单请求：</p><ul><li>Method 为 <code>GET</code> 、<code>HEAD</code> 、<code>POST</code>之一</li><li>Fetch 规定了对CORS安全的首部字段集合，如人为设定了集合之外的其他首部字段，则就不是简单请求了。集合如下<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type 的值仅限于 <code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>请求中的任意<code>XMLHttpRequestUpload</code>对象均没有注册任何时间监听器</li><li>请求中没有使用<code>ReadableStream</code>对象</li></ul><h5 id="请求、响应头部的特点"><a href="#请求、响应头部的特点" class="headerlink" title="请求、响应头部的特点"></a>请求、响应头部的特点</h5><ul><li>请求头部需带上<code>Origin：[originURL]</code></li></ul><p><em> 服务端响应会携带首部字段`Access-Control-Allow-Origin: [originURL] | </em>`</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>不满足简单请求条件的跨域请求都是非简单请求。非简单请求需要先发预检请求，得到允许后，再发送正常请求去请求数据。</p><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>非简单请求必须首先使用<code>OPTIONS</code>方法发起一个预检请求到服务器，以获取服务器是否允许该实际请求</p><ul><li><p>预检请求头部字段</p><ul><li><code>Origin: &lt;origin&gt;</code> 表明预检请求或实际请求的源站</li><li><code>Access-Control-Request-Method: &lt;method&gt;</code> 将实际请求所使用的 HTTP 方法告诉服务器</li><li><code>Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code> 将实际请求所携带的首部字段告诉服务器</li></ul></li><li><p>预检响应首部字段</p><ul><li><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code> 指定了允许访问资源的外域URI</li><li><code>Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code> 指明了实际请求所允许使用的 HTTP 方法</li><li><code>Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code> 指明了实际请求中允许携带的首部字段。</li><li><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code> 指定了预检请求结果能被缓存多久，也就是关于实际请求多久不需要再次发送预检请求</li></ul></li></ul><h3 id="三、window-postMessage"><a href="#三、window-postMessage" class="headerlink" title="三、window.postMessage"></a>三、window.postMessage</h3><p>主要是为了 <code>&lt;iframe&gt;</code> 标签镶嵌的两个页面进行数据通信用的，需要两个页面的前端配合。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>发送 <code>otherWindow.postMessage(msg, targetOrigin [, transfer])</code></li><li>监听  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, func, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin;</span><br><span class="line">  <span class="keyword">if</span> (origin != <span class="string">'http://xxx:8080'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>两个窗口都需要绑定上述方法，才能互相通信。</p><p>### 四、WebSocket</p><p>WebSocket 是独立的、建立在TCP上的协议，是一种在浏览器与服务器之间保持TCP长连接的网络协议，能让浏览器、服务器可以随时进行信息交换，通过HTTP/1.1协议的<strong>101状态码</strong>进行<strong>握手</strong>(浏览器发出请求，之后服务器进行回应)</p><p>在还未有该协议时，使用的是<strong>轮询</strong>的方法，让客户端每隔一段时间都发送请求去询问服务器是否准备好数据了。也就是解决了“客户端无法获知请求的动态资源何时到位“这个问题。</p><p>之所以跟跨域有关系，是因为<strong>当客户端与服务器端创建WebScoket连接后，本身就可以天然的实现跨域资源共享，因为WebSocket协议本身就不受浏览器“同源策略”的限制，同源策略只是限制了跨域的AJAX请求。</strong></p><h4 id="构造函数与属性方法"><a href="#构造函数与属性方法" class="headerlink" title="构造函数与属性方法"></a>构造函数与属性方法</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul><li><code>WebSocket(url[, protocols])</code> 如：let socket = new WebSocket(‘http//baidu.com:8080’)</li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><code>WebSocket.binaryType</code> 使用二进制数据类型进行连接</li><li><code>WebSocket.onclose</code> 指定连接关闭后的回调函数</li><li><code>WebSocket.onerror</code> 指定连接失败后的回调函数</li><li><code>WebSocket.onmessge</code> 指定从服务器接收到信息时的回调函数</li><li><code>WebSocket.onopen</code> 指定连接成功后的回调函数</li><li><code>WebSocket.protocol</code> <strong>只读</strong> 服务器选择的下属协议</li><li><code>WebSocket.readyState</code> <strong>只读</strong> 当前连接状态，0：正在连接中；1：连接成功；2：连接正在关闭；3：连接已经关闭或打开连接失败</li><li><code>WebSocket.url</code> <strong>只读</strong> WebSocket 的绝对路径</li><li><code>WebSocket.bufferedAmount</code> <strong>只读</strong> 未发送至服务器的字节数</li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li><code>WebSocket.close([code, reason])</code> 关闭当前连接</li><li><code>WebSocket.send(data)</code> 向服务器发送数据</li></ul><h4 id="典型的Websocket握手请求"><a href="#典型的Websocket握手请求" class="headerlink" title="典型的Websocket握手请求"></a>典型的Websocket握手请求</h4><h5 id="浏览器请求头"><a href="#浏览器请求头" class="headerlink" title="浏览器请求头"></a>浏览器请求头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: websocket      // 必须，表示希望升级到Websocket协议</span><br><span class="line">Connection: Upgrade     // 必须，表示客户端希望连接升级</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http://example.com   // 客户端的origin，协议和主机名称</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==   // 随机字符串，用来SHA-1、BASE-64编码后，作为`Sec-WebSocket-Accept`头的值返回给客户端</span><br><span class="line">Sec-WebSocket-Version: 13 // RFC6455要求使用的版本是13，之前草案的版本均应当弃用</span><br></pre></td></tr></table></figure><h5 id="服务器响应头"><a href="#服务器响应头" class="headerlink" title="服务器响应头"></a>服务器响应头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'http//baidu.com:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection opened</span></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发送完毕</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 还在发送</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for messages</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Message from server '</span>, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> 请求 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XMLHttoRequest </tag>
            
            <tag> Fetch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 文档不熟悉知识汇总</title>
      <link href="/2018/10/24/React-%E6%96%87%E6%A1%A3%E4%B8%8D%E7%86%9F%E6%82%89%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
      <url>/2018/10/24/React-%E6%96%87%E6%A1%A3%E4%B8%8D%E7%86%9F%E6%82%89%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="React-官方文档"><a href="#React-官方文档" class="headerlink" title="React 官方文档"></a>React 官方文档</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ul><li><p>React 可以将多个setState() 调用合并成一个调用来提高性能，所以 this.props​ 与 this.state 是异步更新的，若想根据上个state来更新state，则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; (&#123;</span><br><span class="line">  count: prevState.count + props.num</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p>React 中，事件处理函数中阻止默认行为不能返回 false ，而是用  e.preventDefault(); 来解决 , e 是个合成事件，已解决了跨浏览器兼容问题；通过箭头函数，e 必须显示进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式进行传递。</p></li><li>数组元素必须为每个项配置一个key，并且在其兄弟中是独一无二的，并不需要在全局中唯一</li><li><strong>状态提升</strong>：任何可变的数据理应只有一个单一数据源，应在应用中保持自上而下的数据流，也就是把两个及以上组件共同使用的数据提升到其父组件上，而不是在不同组件中同步状态。</li><li>如果某些数据既可用 state 又可用 props 提供，那么它很有可能不应该在 state 中出现。</li><li>如果一个数据不是动态改变并且影响到渲染的，那么就不应该添加在 state 里。</li><li><strong>单一功能原则</strong>：尽量维持一个组件只做一件事情，如果这个组件的功能不断丰富，它应该被分成更小的组件</li><li>JSX 只是为了 <code>React.createElement(component, props, children)</code> 方法提供了语法糖。</li><li><p>Context 提供了一种在组件之间共享数据的方式，而不必通过组件树的每个层级显式地传递 props 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123;Provider, Consumer&#125; = React.createContext(defaultValue);</span><br><span class="line"></span><br><span class="line">&lt;Provider value=&#123;/* some value */&#125;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;value =&gt; /* render something based on the context value */&#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure><p>每当Provider的值发送改变时, 作为Provider后代的所有Consumers都会重新渲染。 从Provider到其后代的Consumers传播不受shouldComponentUpdate方法的约束，因此即使祖先组件退出更新时，后代Consumer也会被更新。</p><p>高阶组件封装context</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class="line"></span><br><span class="line">// 在函数中引入组件</span><br><span class="line">export function withTheme(Component) &#123;</span><br><span class="line">  // 然后返回另一个组件</span><br><span class="line">  return function ThemedComponent(props) &#123;</span><br><span class="line">    // 最后使用context theme渲染这个被封装组件</span><br><span class="line">    // 注意我们照常引用了被添加的属性</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        &#123;theme =&gt; &lt;Component &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="了解："><a href="#了解：" class="headerlink" title="了解："></a>了解：</h3><ul><li>使用propTypes进行props类型检查，如 <code>Demo.propTypes = {...};</code> ，出于性能原因， propTypes只在开发模式下进行检查</li><li><p><strong>Refs</strong>: 不能在函数式组件上使用 ref 属性，因为它们没有实例；当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref；当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。ref 的更新会发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    // 创建 ref 存储 textInput DOM 元素</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">    this.focusTextInput = this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    // 直接使用原生 API 使 text 输入框获得焦点</span><br><span class="line">    // 注意：通过 &quot;current&quot; 取得 DOM 节点</span><br><span class="line">    this.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 告诉 React 我们想把 &lt;input&gt; ref 关联到构造器里创建的 `textInput` 上</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      ref=&#123;this.textInput&#125; /&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;input</span><br><span class="line">      type=&quot;button&quot;</span><br><span class="line">      value=&quot;Focus the text input&quot;</span><br><span class="line">      onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  一个关于渲染属性API的问题是 refs 不会自动的传递给被封装的元素。为了解决这个问题，使用 React.forwardRef<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class FancyButton extends React.Component &#123;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 context 传递当前的 &quot;theme&quot; 给 FancyButton.</span><br><span class="line">// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.</span><br><span class="line">export default React.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;theme =&gt; (</span><br><span class="line">      &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure></p><ul><li><strong>协同算法</strong>：<ol><li>两个不同类型的元素将产生不同的树。</li><li>通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。</li><li>当对比两棵树时，React首先比较两个根节点。每当根元素有不同类型，React将卸载旧树并重新构建新树。</li><li>当比较两个相同类型的React DOM元素时，React则会观察二者的属性，保持相同的底层DOM节点，并仅更新变化的属性。当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留</li><li>当递归DOM节点的子节点，React仅在同一时间点递归两个子节点列表，并在有不同时产生一个变更。为解决该问题，React支持了一个key属性。当子节点有key时，React使用key来匹配原本树的子节点和新树的子节点。</li><li>Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。</li></ol></li><li>Fragments: React 中一个常见模式是为一个组件返回多个元素。Fragments 可以让你聚合一个子元素列表，并且不在DOM中增加额外节点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;   // fragments</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>###初次知道：</p><ul><li>静态类型检查：使用 Flow 和 TypeScript 静态类型检查器可以在运行代码之前识别某些类型问题</li><li>Create React App</li><li>uglify-js-brunch</li><li>Browserify</li><li>Rollup</li><li>使用 Chrome Performance 归档组件</li><li>Immutable.js是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：</li><li>Portals 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或碎片。第二个参数（container）则是一个 DOM 元素。对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上“跳出（break out）”其容器。例如，对话框、hovercards以及提示框：<br><code>ReactDOM.createPortal(child, container)</code></li><li><p><strong>错误边界:</strong> 如果一个类组件定义了一个名为 componentDidCatch(error, info): 的新方法，则其成为一个错误边界</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  // Display fallback UI</span><br><span class="line">  this.setState(&#123; hasError: true &#125;);</span><br><span class="line">  // You can also log the error to an error reporting service</span><br><span class="line">  logErrorToMyService(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>web组件 </p></li><li>虚拟DOM（VDOM）是一种编程概念，是指虚拟的视图被保存在内存中，并通过诸如ReactDOM这样的库与“真实”的DOM保持同步。这个过程被称为和解。fiber是React 16中新的和解引擎。它的主要目的是使虚拟DOM能够进行增量渲染</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>学习Vue.js第一天</title>
      <link href="/2016/06/13/image-compression/"/>
      <url>/2016/06/13/image-compression/</url>
      
        <content type="html"><![CDATA[<p>  Vue.js是一个数据驱动组件，由于工作需要，现开始学习，并做下学习笔记，以备今后查询解惑</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>vue.js是一个构建数据驱动的web界面的库，通过简单的api实现 <strong>响应的数据绑定</strong>  和  <strong>组合的视觉组件</strong>                </p></li><li><p>vue.js 的绑定视图DOM的方法与 angualar.js 很相似</p></li><li><p><strong>v-if</strong>  特性被称作指令。指令带有前缀 <strong>v-</strong> ，代表vue.js提供的特性，它们会给绑定的目标添加响应式的特殊行为。</p></li></ol><h2 id="组件的应用模板"><a href="#组件的应用模板" class="headerlink" title="组件的应用模板"></a>组件的应用模板</h2><pre><code>&lt;div id = &quot;app&quot;&gt;    &lt;app-nav&gt;&lt;/app-nav&gt;   &lt;app-view&gt;       &lt;app-sidebar&gt;&lt;/app-sidebar&gt;       &lt;app-content&gt;&lt;/app-content&gt;   &lt;/app-view&gt;&lt;/div&gt;</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h3 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a><strong>MVVM</strong> 模式</h3><pre><code>var vm = new Vue({     // MVVM模式中描述的ViewModel       //选项(数据、模板、挂载元素、方法、生命周期钩子)})</code></pre><h3 id="创建可复用的组件构造器"><a href="#创建可复用的组件构造器" class="headerlink" title="创建可复用的组件构造器"></a>创建可复用的组件构造器</h3><pre><code>所有的Vue.js组件其实都是被扩展的vue实例 var Mycomponent = Vue.extend({        // 扩展选项 })  // 所有的 ‘Mycomponent’ 实例都将以预定义的扩展选项被创建 var myComponentInstance = new Mycomponent()</code></pre><h2 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h2><h3 id="代理数据属性（响应）"><a href="#代理数据属性（响应）" class="headerlink" title="代理数据属性（响应）"></a>代理数据属性（响应）</h3><pre><code>每个vue实例都会代理其 **data** 对象里的所有属性   var data = { a : 1 }   var vm = new Vue ({       el: &apos;#example&apos;       data: data   })   vm.a === data.a   // true</code></pre><h3 id="实例属性与方法（带前缀-）"><a href="#实例属性与方法（带前缀-）" class="headerlink" title="实例属性与方法（带前缀 $）"></a>实例属性与方法（带前缀 <strong>$</strong>）</h3><pre><code>vm.$data === data  // truevm.$el === document.getElementById(&apos;example&apos;)   // true// $watch 是一个方法vm.$watch(&apos;a&apos;, function (newVal, oldVal) {    //这个回调将会在 &apos;vm.a&apos; 改变后调用})</code></pre><h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>   vue.js没有“控制器”的概念，组件的自定义逻辑都是分割在各种生命周期钩子上，<br>   包括 <strong>compiled</strong>、<strong>ready</strong>、<strong>destroyed</strong>、<strong>creaded</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/2145995-bc1002f101418414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/2145995-5dd367e30395c073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图示"></p>]]></content>
      
      
      <categories>
          
          <category> 阿里web前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> Angular.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 Yelee 主题背景图的压缩与优化</title>
      <link href="/2016/05/24/image-compression/"/>
      <url>/2016/05/24/image-compression/</url>
      
        <content type="html"><![CDATA[<p>目前主题里可以使用多张随机大图作背景，如果不做好图片压缩和优化，可能会严重影响网站的流畅性。下面简单介绍两种比较简单便捷的优化方案。</p><a id="more"></a><h2 id="优化说明"><a href="#优化说明" class="headerlink" title="优化说明"></a>优化说明</h2><ul><li>请使用<code>jpg</code>后缀名的背景图片；</li><li>如果可以，使用<code>渐进式JPEG</code>，让图片加载时逐渐清晰；</li><li>将图片品质尽量调低，一般可以压缩到几十kb（背景图半透明显示，因此细节并不重要）；<blockquote><p>图1 为目前主题自带背景图的分辨率和文件大小展示<br>图2 为渐进式图片加载示例</p></blockquote></li></ul><p><img src="/resources/image-compression-1.png" alt="Yelee Background info.">  <img src="/resources/image-compression-2.gif" alt="Progressive JPEGs"></p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="PhotoShop"><a href="#PhotoShop" class="headerlink" title="PhotoShop"></a>PhotoShop</h3><ul><li>电脑上如果安装了PhotoShop，那用其来优化图片那是再好不过了</li><li>PS 打开图片 -&gt; 文件 -&gt; 存储为 Web 所用格式 -&gt; JPEG 格式，品质 0，勾选 <code>连续</code>（渐进式），最后存储，这样一张高压缩渐进式的 JPG 背景图就做好了</li></ul><p><img src="/resources/image-compression-ps.png" alt="image Compression by PhotoShop"></p><h3 id="智图"><a href="#智图" class="headerlink" title="智图"></a>智图</h3><ul><li><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">智图</a> 是腾讯 ISUX 出品的在线图片优化工具，可以方便的对比优化前后的图片，同时可以自行调节图片品质，除了不能设置 <code>渐进式JPEG</code>，其他基本满足背景图片优化需求</li><li>进入网站后按提示上传图片，在调低图片品质，之后下载图片即可<blockquote><p>因为主题背景图为 <code>jpg</code>格式，其他格式请转为 <code>jpg</code> 格式后再上传到网上优化。转换的方式有很多，比如，打开图片预览后另存为jpg</p></blockquote></li></ul><p><img src="/resources/zhitu.png" alt="智图"></p><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>原图为 420kb，智图选择最低品质(10)后约为 129kb；</li><li>PhotoShop 选择最低品质 0，可以压缩到 62k，同时可以选择为 <code>渐进式JPEG</code>；</li><li>因此，有条件的话，更推荐使用 PS 压缩图片。</li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><strong>智图</strong>： <a href="http://zhitu.isux.us/" target="_blank" rel="noopener">http://zhitu.isux.us/</a></li><li><strong>TinyPNG</strong>： <a href="http://tinypng.com/" target="_blank" rel="noopener">http://tinypng.com/</a></li><li><strong><em>渐进式</em></strong>： by <strong>张鑫旭</strong> on <code>2013/01/07</code>: <a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/</a></li><li><strong>呆毛王示例壁纸下载</strong> <a href="http://moxfive.xyz/resources/saber.jpg" target="_blank" rel="noopener">http://moxfive.xyz/resources/saber.jpg</a></li><li><strong>最人性化的壁纸网站</strong> <a href="http://www.wallpaperpcmobile.com/" target="_blank" rel="noopener">http://www.wallpaperpcmobile.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 术业有专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yelee </tag>
            
            <tag> PhotoShop </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
