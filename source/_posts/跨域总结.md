---
title: 常见跨域总结
date: 2018-11-20 16:00
tags:
- AJAX
- 跨域
toc: true
reward: true
---
面试时经常会被问到跨域问题，因此，在此做个详细的总结
<!-- more -->

# 跨域总结

## 为什么会出现跨域问题

* 出于浏览器同源策略限制，浏览器会拒绝跨域的读操作请求。
* 同源策略是一个用于隔离潜在恶意文件的重要安全机制。
* 同源的定义： 如果两个页面的协议、端口、域名都相同，则同源。非同源请求，均为跨域

## 如何实现跨域

  最常用的跨域方式有以下四种：**JSONP、 CORS、 postMessage、 WebSocket**

### 一、JSONP

**JSONP是一种比较hack的方式，单纯的为了实现跨域请求而创造的一个trick.**

JSONP的核心是动态添加< script >标签来调用服务器提供的js脚本。ajax的核心是通过XMLHttpRequest获取非本页内容。

#### 优缺点

* 优点： 兼容性好，能兼容到低版本IE
* 缺点： 1.JSONP只支持GET请求；2.XMLHttpRequest相对于JSONP有着更好的错误处理机制 

#### 实现方式（需前后端配合）

原理： < script >标签的src属性是可以跨域的。传递一个`callback`参数给跨域服务端，返回数据时将这个`callback`参数作为函数名包裹要返回的json数据。

* webA的前端

  ```html
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>JSONP</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <p>JSONP Demo</p>
    <p class="main"></p>
  </body>
  <!-- 第一种方式 -->
  <!-- <script>
    function getData(data) {
      var text = document.createElement('p');
      text.innerHTML = data;
      document.getElementsByTagName('body')[0].appendChild(text);
    }
  </script> -->
  <!-- <script src="http://localhost:3003/jsonp?callback=getData"></script> -->

  <!-- 第二种方式 -->
  <script>
    function getData(data) {
      var text = document.createElement('p');
      text.innerHTML = data;
      document.getElementsByTagName('body')[0].appendChild(text);
    }
    var url = 'http://localhost:3003/jsonp?callback=getData';
    var script = document.createElement('script');
    script.setAttribute('src', url);
    document.getElementsByTagName('head')[0].appendChild(script);
  </script>
  </html>
  ```

* webA的后端
  * node.js

  ```javascript
  const Koa = require('koa');
  const fs = require('fs');
  const app = new Koa();

  app.use(async ctx => {
    if (ctx.url === '/') {
      ctx.body = fs.readFileSync('./jsonp.html', { encoding: 'utf8' })
    }
  });

  app.listen(3001);
  ```

* webB的后端
  * php

  ```php  
  <?php
    $callback = $_GET['callback']; // 得到回调函数名
    $data = 'demo';  // 要返回的数据
    echo $callback.'('.json_encode($data).')'; // 输出回前端
  >
  ```

  * node.js

  ```javascript
  const Koa = require('koa');
  const app = new Koa();

  app.use(async ctx => {
    if (ctx.originalUrl.split('?')[0] === '/jsonp') {
      let callback = ctx.originalUrl.split('?')[1].split('=')[1];
      let data = '连接成功！';
      ctx.body = `${callback}('${data}')`
    } else {
      ctx.body = 'Hello World';
    }
  });
  app.listen(3003);
  ```

### 二、CORS（跨域资源共享 cross-origin sharing standard）

* CORS 是W3C推荐的一种新的官方方案，能使服务器支XMLHttpRequest的跨域请求。
* CORS实现起来非常方便，只需增加一些HTTP头，让服务器能声明允许的访问来源。
* 通常使用CORS时，异步请求会被分为简单请求和非简单请求，区别是，非简单请求会先使用`OPTIONS`方法发起一个预检请求(`prefight request`)，获知服务端是否允许跨域请求
* 需要后端接口配合，加上一些响应头字段

#### 简单请求

满足以下条件的可视为简单请求：

* Method 为 `GET` 、`HEAD` 、`POST`之一
* Fetch 规定了对CORS安全的首部字段集合，如人为设定了集合之外的其他首部字段，则就不是简单请求了。集合如下
  * Accept
  * Accept-Language
  * Content-Language
  * Content-Type 的值仅限于 `text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`
  * DPR
  * Downlink
  * Save-Data
  * Viewport-Width
  * Width
* 请求中的任意`XMLHttpRequestUpload`对象均没有注册任何时间监听器
* 请求中没有使用`ReadableStream`对象

##### 请求、响应头部的特点

* 请求头部需带上`Origin：[originURL]`

* 服务端响应会携带首部字段`Access-Control-Allow-Origin: [originURL] | *`

#### 非简单请求

不满足简单请求条件的跨域请求都是非简单请求。非简单请求需要先发预检请求，得到允许后，再发送正常请求去请求数据。

##### 预检请求

非简单请求必须首先使用`OPTIONS`方法发起一个预检请求到服务器，以获取服务器是否允许该实际请求

* 预检请求头部字段
  * `Origin: <origin>` 表明预检请求或实际请求的源站
  * `Access-Control-Request-Method: <method>` 将实际请求所使用的 HTTP 方法告诉服务器
  * `Access-Control-Request-Headers: <field-name>[, <field-name>]*` 将实际请求所携带的首部字段告诉服务器

* 预检响应首部字段
  * `Access-Control-Allow-Origin: <origin> | *` 指定了允许访问资源的外域URI
  * `Access-Control-Allow-Methods: <method>[, <method>]*` 指明了实际请求所允许使用的 HTTP 方法
  * `Access-Control-Allow-Headers: <field-name>[, <field-name>]*` 指明了实际请求中允许携带的首部字段。
  * `Access-Control-Max-Age: <delta-seconds>` 指定了预检请求结果能被缓存多久，也就是关于实际请求多久不需要再次发送预检请求

#### 例子

如果用的koa框架搭建的后台，可以用`koa-cors`中间件来配置

```javascript
const Koa = require('koa');
var cors = require('koa-cors');
const app = new Koa();

// cors跨域配置
app.use(cors({
  origin: '*',
  headers: ['Cache-Control', 'Content-Type'],
  methods: ['GET', 'PUT', 'POST']
}));

app.use(async ctx => {
  if (ctx.originalUrl.split('?')[0] === '/jsonp') {
    let callback = ctx.originalUrl.split('?')[1].split('=')[1];
    let data = '连接成功！';
    ctx.body = `${callback}('${data}')`
  } else if (ctx.url === '/corsPostSomething') {
    console.log('ctx11', ctx);
    ctx.body = '跨域过来的东西收到了';
  } else {
    ctx.body = 'Hello World';
  }
});

app.listen(3003);
```

### 三、window.postMessage

主要是为了 `<iframe>` 标签镶嵌的两个页面进行数据通信用的，需要两个页面的前端配合。

#### 语法

* 发送 `otherWindow.postMessage(msg, targetOrigin [, transfer])`
* 监听
    ```javascript
    window.addEventListener("message", func, false);
    function func(event) {
      var origin = event.origin;
      if (origin != 'http://xxx:8080') {
        return;
      }
      ...
    }
    ```
两个窗口都需要绑定上述方法，才能互相通信。

#### 例子

webA的代码(主页面，用`iframe`嵌入webB):

```html
<body>
  <h3>下面是内嵌页面</h3>
  <iframe id="child" height="200" width="200" contentWindow="webBPage" src="http://localhost:3003"><p>Your browser does not support iframes.</p></iframe>
</body>
<script>
  // 一定是页面加载完成后在发送消息，否则会因为 iframe 未加载完成报错
  window.onload = function(){
    document.getElementById('child').contentWindow.postMessage("主页面消息", "http://localhost:3003")
  }

  function receiveMessage(event){
    // 我们能相信信息的发送者吗?  (也许这个发送者和我们最初打开的不是同一个页面).
    if (event.origin !== "http://localhost:3003") return;

    var text = document.createElement('p');
    text.innerHTML = event.data;
    document.getElementsByTagName('body')[0].appendChild(text);
  }
  window.addEventListener("message", receiveMessage, false);
</script>
```

webB的代码：

```html
<body>
  <p>webB页面</p>
</body>
<script>
  function receiveMessage(event) {
    if (event.origin !== "http://localhost:3001") return;

    var text = document.createElement('p');
    text.innerHTML = event.data;
    document.getElementsByTagName('body')[0].appendChild(text);

    // 作为回信的对象，并且把event.origin作为targetOrigin
    event.source.postMessage("这是B呀", event.origin);
  }

window.addEventListener("message", receiveMessage, false);
</script>
```

### 四、WebSocket

WebSocket 是独立的、建立在TCP上的协议，是一种在浏览器与服务器之间保持TCP长连接的网络协议，能让浏览器、服务器可以随时进行信息交换，通过HTTP/1.1协议的**101状态码**进行**握手**(浏览器发出请求，之后服务器进行回应)

在还未有该协议时，使用的是**轮询**的方法，让客户端每隔一段时间都发送请求去询问服务器是否准备好数据了。也就是解决了“客户端无法获知请求的动态资源何时到位“这个问题。

之所以跟跨域有关系，是因为**当客户端与服务器端创建WebScoket连接后，本身就可以天然的实现跨域资源共享，因为WebSocket协议本身就不受浏览器“同源策略”的限制，同源策略只是限制了跨域的AJAX请求。**

#### 构造函数与属性方法

##### 构造函数

* `WebSocket(url[, protocols]) ` 如：let socket = new WebSocket('http//baidu.com:8080')

##### 属性

* `WebSocket.binaryType` 使用二进制数据类型进行连接
* `WebSocket.onclose` 指定连接关闭后的回调函数
* `WebSocket.onerror` 指定连接失败后的回调函数
* `WebSocket.onmessge` 指定从服务器接收到信息时的回调函数
* `WebSocket.onopen` 指定连接成功后的回调函数
* `WebSocket.protocol` **只读** 服务器选择的下属协议
* `WebSocket.readyState` **只读** 当前连接状态，0：正在连接中；1：连接成功；2：连接正在关闭；3：连接已经关闭或打开连接失败
* `WebSocket.url` **只读** WebSocket 的绝对路径
* `WebSocket.bufferedAmount` **只读** 未发送至服务器的字节数

##### 方法

* `WebSocket.close([code, reason])` 关闭当前连接
* `WebSocket.send(data)` 向服务器发送数据

#### 典型的Websocket握手请求

##### 浏览器请求头

```
GET / HTTP/1.1
Upgrade: websocket      // 必须，表示希望升级到Websocket协议
Connection: Upgrade     // 必须，表示客户端希望连接升级
Host: example.com
Origin: http://example.com   // 客户端的origin，协议和主机名称
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==   // 随机字符串，用来SHA-1、BASE-64编码后，作为`Sec-WebSocket-Accept`头的值返回给客户端
Sec-WebSocket-Version: 13 // RFC6455要求使用的版本是13，之前草案的版本均应当弃用
```

##### 服务器响应头

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/
```

#### 例子

http 为 ws, https 为 wss

```javascript
let socket = new WebSocket('ws//baidu.com:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
    if (socket.bufferedAmount === 0) {
    // 发送完毕
    } else {
        // 还在发送
    }

});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});
```

